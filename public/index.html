<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Glücksrad</title>
    <link rel="stylesheet" href="style.css"> </head>
</head>
<body>
    <div class="container">
        <h1>Glücksrad</h1>
        <div class="wheel-container">
            <div class="wheel" id="wheel">
                </div>
            <div class="pointer"></div>
        </div>
        <button id="spinButton">Drehen</button>
        <p id="statusMessage" class="status-message"></p>
    </div>

    <script src="/socket.io/socket.io.js"></script>
    <script>
        const socket = io();
        const wheel = document.getElementById('wheel');
        const spinButton = document.getElementById('spinButton');
        const statusMessage = document.getElementById('statusMessage');

        let segments = [];
        let spinning = false;

        // Funktion zum Zeichnen der Radsegmente
        function drawWheel(segmentsConfig) {
            segments = segmentsConfig;
            wheel.innerHTML = ''; // Vorhandene Segmente löschen

            if (segments.length === 0) {
                statusMessage.textContent = 'Bitte fügen Sie Segmente auf der Konfigurationsseite hinzu.';
                spinButton.disabled = true;
                return;
            }

            spinButton.disabled = false; // Button aktivieren, wenn Segmente vorhanden sind

            const numSegments = segments.length;
            const segmentAngle = 360 / numSegments; // Winkel jedes Segments

            segments.forEach((segment, index) => {
                const segmentElement = document.createElement('div');
                segmentElement.classList.add('wheel-segment');
                segmentElement.style.backgroundColor = segment.color;
                
                // Positionierung und Formung des Segments
                segmentElement.style.transform = `rotate(${segmentAngle * index}deg)`;
                
                // Erstellen des Segmentinhalts
                const segmentContent = document.createElement('div');
                segmentContent.classList.add('segment-content');
                segmentContent.textContent = segment.text;
                
                // Textpositionierung und -ausrichtung
                segmentContent.style.transform = `rotate(${segmentAngle/2}deg)`;
                segmentContent.style.transformOrigin = 'left center';
                segmentContent.style.left = '50%';
                
                // Dynamische Anpassungen basierend auf Segmentanzahl
                const baseFontSize = Math.min(1.1, 1.5 - (numSegments * 0.03));
                const basePadding = Math.max(10, 35 - (numSegments * 1.5));
                
                segmentContent.style.fontSize = `${baseFontSize}em`;
                segmentContent.style.paddingTop = `${basePadding}px`;


                segmentElement.appendChild(segmentContent);
                wheel.appendChild(segmentElement);
            });
        }

        // Anfängliche Segmentkonfiguration vom Server
        socket.on('segmentsConfig', (config) => {
            segments = config;
            drawWheel(segments);
        });


        spinButton.addEventListener('click', () => {
            if (!spinning && segments.length > 0) {
                socket.emit('spinWheel');
                spinButton.disabled = true;
                statusMessage.textContent = 'Warte auf Drehung...';
            }
        });

        socket.on('wheelSpun', (data) => {
            const { targetRotation, winningSegment } = data; // randomIndex wird hier nicht mehr benötigt
            console.log(`Spin-Daten empfangen: Zielrotation ${targetRotation}, Gewinnsegment: ${winningSegment.text}`);

            spinning = true;
            wheel.style.transition = 'transform 4s cubic-bezier(0.25, 0.1, 0.25, 1)'; // Transition anwenden
            wheel.style.transform = `rotate(${targetRotation}deg)`;

            // Auf das Ende der Transition warten
            wheel.addEventListener('transitionend', () => {
                spinning = false;
                spinButton.disabled = false;
                statusMessage.textContent = `Gewinner: ${winningSegment.text}`;

                // Transformation zurücksetzen, um große Rotationswerte zu vermeiden
                // Die tatsächliche visuelle Position wird beibehalten
                const currentRotation = targetRotation % 360;
                wheel.style.transition = 'none'; // Temporär Transition entfernen
                wheel.style.transform = `rotate(${currentRotation}deg)`; // Auf die tatsächliche visuelle Position zurücksetzen

                // Einen Reflow erzwingen, um sicherzustellen, dass die Transition vor dem nächsten Spin zurückgesetzt wird
                void wheel.offsetWidth;
            }, { once: true }); // { once: true } verwenden, um sicherzustellen, dass der Event-Listener nach dem Auslösen entfernt wird
        });
    </script>
</body>
</html>
